什么是线程
·在一个程序里的一个执行路线叫做线程，更准确的定义是：线程是“进程内部的控制序列”
·一切进程至少有一个执行线程
·线程在进程内部运行，本质是在进程地址空间内运行
·在Linux系统中，在CPU眼中，看到的PCB都要比传统进程更加轻量化
·透过进程虚拟地址空间，可以看到进程的大部分资源，将进程资源合理分配给每个执行流，就形成 了线程执行流

线程量级比进程小

Linux中的进程我们称为轻量级进程：CPU在调度的时候，看到的是个PCB有可能是个轻量级的PCB（PCB中的一部分）内部多个执行流
Linux中没有真正意义上的线程，线程是由进程模拟的。

进程是承担分配系统资源的实际意义

线程本身在进程中，谈到线程就想到是进程中多了PCB，并将一些资源分配给它。

一个进程看到的资源都是通过地址空间看到的。一个进程包括多个执行流。一个进程就像一个家庭，线程就像是家庭成员，很多东西都是共享的。

进程切换要切换上下文虚拟地址和页表，线程只需要切换上下文就行。

计算密集型？？？？

线程异常：
·单个线程如果出现除零，野指针问题导致线程崩溃，进程也会随之崩溃
·线程是进程的执行分支，线程出异常，就类似进程出异常，进而出发信号机制，终止进程，进程终止，该进程内的所有线程也就随之退出。

线程用途：
·合理的使用多线程，么美好提高CPU密集型程序的执行效率
·合理使用多线程，能提高IO密集型程序的用户体验（如生活中我们一边写代码一边下载东西，就是多线程运行的一种表现）

进程和线程
·进程是资源分配的基本单位
·线程是调度的基本单位
·线程共享进程数据，但也拥有自己的一部分数据
    ·线程id
    ·一组寄存器（上下文）
    ·栈（运行时栈）
    ·errno
    ·信号屏蔽器
    ·调度优先级


进程的多个线程共享
同一地址空间，因此text Segment  Data Segment都是共享的，如果定义一个函数，在各线程中都可以调用，如果定义一个全局变量，在各线程中都可以访问到，除此之外，各线程还可以共享以下进程资源和环境：
·文件描述符
·各种信号的处理方式
·当前工作目录
·用户id和组id

我们看到的pid在底层看到的是tid,操作系统调度的时候是调动pid
用户态的ipd

线程退出（三种方式）



是线程属性的分离

线程的互斥：
线程中共享的资源叫临界资源，访问它的代码叫做临界区
只有一个执行流可以访问和使用资源（互斥）
原子性就是要么完成，要么未完成
某一个执行流长时间进入不了临界区，称为饥饿问题
可以按顺序更合理的访问临界资源（同步）


互斥锁：mutex
在临界区放锁

互斥锁提供等待的队列，如果申请不到锁就得等待被挂起
如何实现互斥
采用一条汇编语句，保存互斥的原子性

可重入VS线程安全
概念：
·线程安全：多个线程并发同一段代码时，不会出现不同的结果，常见对全局变量或者静态变量进程操作，并且没有锁的保护的情况下，会出现该问题
·重入：同一个函数被不同的执行流调用，当前一个流程还没有执行完，就有其他的执行流再次进入，我们称之为重入，一个函数在重入的情况下，运行结果不会出现不同或者任何问题，则该函数被称为可重入函数，否则，是不可重入函数。
常见的线程不安全的情况：
·不保护贡献变量的函数
·函数状态随着被调用，状态发生变化的函数
·返回指向静态变量指针的函数
·调用线程不安全函数的函数
常见的线程安全的情况：·每个线程对全局变量或者静态变量只有读取的权限，而没有写入的权限，一般来说是安全的
·类或者接口对于线程来说都是原子操作
·多个线程之间的切换不会导致该接口的执行结果存在二义性
常见的不可重入函数的情况
·调用了malloc/free函数，因为malloc是用


申请锁失败：锁被别人拿走，所以当前的线程就会被挂起。
互斥锁的原理：


释放锁-->等待3

支持并发


悲观锁：总担心数据会被修改，取数据前先加锁。
乐观锁：认为数据不会被修改，因此不上锁，但在更新数据前，会判断其它数据在更新前有没有对数据进行修改。
CAS操作：原子操作
自旋锁：打电话的过程（李四等待张三），询问张三还需要多久时间下来，不停确认下来的时间。自旋的方式申请锁资源，别人在临界区的时间太短，需要等待的时间太短，不需要被挂起等待。读写锁就是自选锁
公平锁：
非公平锁：

二元信号锁：是挂起等待锁。

总结：
1.线程和进程的区别
2.线程操作
3.线程的同步与互斥
4.单例模式（懒汉饿汉），线程安全。
